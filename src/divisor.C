/* Implementation of genus 2 divisor arithmetic over V. Shoup's 
   NTL library 
*/

#if HAVE_CONFIG_H
#include <config.h>
#endif

#include <assert.h>
#include <g2hec_Genus2_ops.h>

NS_G2_START_IMPL

/*****************************************************\
 Initialize static member s_hcurve of class divisor
\*****************************************************/
g2hcurve my_curve;
g2hcurve divisor::s_hcurve = my_curve;

void divisor::update() {
  bool_t OK = TRUE;

  // Check curve's validity
  OK = OK && s_hcurve.is_valid_curve();

  /* Check if [u, v] belongs to Jacobian of genus 2 curve
   It is so if
   (1) u is monic
   (2) deg(v) < deg(u) <= genus = 2
   (3) u | v^2 + v*h - f
  */

  OK = OK && IsOne( LeadCoeff(upoly) ); // (1)

  OK = OK && ( deg(upoly) <= genus ) && ( deg(vpoly) < deg(upoly) ); // (2)

  OK = OK && IsZero(( vpoly*(vpoly + s_hcurve.get_h()) 
                      - s_hcurve.get_f() ) % upoly ); // (3)

  // Set is_valid flag
  is_valid = OK;

}


bool_t divisor::is_valid_divisor() const {
  return is_valid;
}

bool_t divisor::is_unit(){
  assert(is_valid); // Invalid divisor is checked runtime error

  return ( IsOne(upoly) && IsZero(vpoly) );
}

void divisor::set_unit() {
  assert(s_hcurve.is_valid_curve()); // Invalid curve is checked runtime error

  clear(vpoly); // vpoly = 0
  set(upoly); // upoly = 1
  update();
}

divisor& divisor::random(divdeg_t dgr){ // Underlying curve is not touched
  assert(s_hcurve.is_valid_curve());

  // A random valid divisor is generated by the following algorithm:
  // generate a degree 1 divisor [x - a1, b1] by choosing a1 by random
  // then trying to solve quadratic equation
  // x^2 + h(a1)*x - f(a1) for b1.
  // Note that finding a root of an equation by calling routine
  // FindRoot(root, poly) may go into an infinite loop if poly does
  // not split completely.  We avoid this by calling irreducibility 
  // test routine DetIrredTest(poly).  After a degree 1 divisor is
  // found, this divisor is doubled by calling add_cantor() to return
  // a degree 2 polynomial.

  field_t a1, b1, f_of_a1, h_of_a1;

  poly_t poly;  // polynomial x^2 + h(a1)*x - f(a1)

  SetCoeff(poly, 2); // set degree 2 leading term to 1

  do {
    do{
      NTL_NNS random(a1);

      eval(f_of_a1, s_hcurve.get_f(), a1);

      eval(h_of_a1, s_hcurve.get_h(), a1);

      SetCoeff(poly, 1, h_of_a1);
      SetCoeff(poly, 0, - f_of_a1);

    } while ( DetIrredTest(poly) );

  FindRoot(b1, poly);

    // Set upoly = x - a1
    SetX(upoly);
    SetCoeff(upoly, 0, -a1);

    // Set vpoly = b1
    vpoly = b1;

    update();
  } while (*this == -*this); // Avoid getting unit after doubling

  // return a degree one divisor if dgr = 1
  if (dgr == DEGREE_1)
    return *this;

  // Double the degree 1 divisor to get a degree 2 divisor, otherwise
  add_cantor(*this, *this, *this);

  if (is_valid_divisor())
    return *this;

  cerr << "Random divisor failed to generate" << endl;
  abort();
}


divisor& divisor::random() {
  return random(DEGREE_2);
}


std::ostream& operator<<(std::ostream& s, const divisor& a)
{
  s << "###" << endl;

s << "Divisor [u(x), v(x)] for Jacobian group of curve y^2 + h(x)*y = f(x)." 
  << endl;

// print curve info
 s << a.get_curve();

 // print u, v
 s << "[u(x), v(x)]:" << endl;

 s << "       u(x) = ";

 print_poly(a.get_upoly(), &s);

 s << "       v(x) = ";
 print_poly(a.get_vpoly(), &s); 

// Is divisor valid?
 if (a.is_valid_divisor())
   s << "       Divisor is valid" << endl;
 else
   s << "       Divisor is invalid" << endl;

 s << "###" << endl;

 return s;
}

NS_G2_END_IMPL
