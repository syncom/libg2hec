/* Test */
/* Note that because we have a static g2hcurve member s_hcurve in the
divisor class and this memeber may result in chaos when we swith moduli, 
we require that there is only one modulus per process
*/

#include <g2hec_nsfieldtype.h>
#include <assert.h>
#include <g2hec_Genus2_ops.h>
#include <g2hec_nsdebug.h>

#undef MAX_STRING_LEN 
#define MAX_STRING_LEN 300

NS_G2_CLIENT

static void compare(const divisor& div, const divisor& divc, string ops);

int main() 
{
  /* Set PRNG seed */
  SetSeed(to_ZZ(19800729));

  char p[MAX_STRING_LEN], exp[MAX_STRING_LEN];

  cout << "Please choose your modulus p (up to " 
<< MAX_STRING_LEN << " decimal digits):" << endl;
  cout << "p = ";
  cin.getline(p, MAX_STRING_LEN);

  ZZ n; // For scalar multiplication

   field_t::init(to_ZZ(p)); // define GF(p)

   poly_t f, h, u, v;

   g2hcurve curve;

   divisor div, divc, div1, div2;

   random(f, 6);
   SetCoeff(f, 5, 1); // Make monic of degree 5

   random(h, 3);

   cout << endl; 

   /*****************************************\
      Test curve 
   \*****************************************/
   cout << "The underlying finite field is GF(" << p << ")." << endl;

   cout << "\t*** Test g2hcurve ***" << endl;

   /* Valid curve 1 generated by g2hcurve::random() */
   cout << "- Valid curve 1 -" << endl;

   /* Test g2hcurve::random */

   cout << "\t*** Test random curve ***" << endl; 

   curve.random();

   assert(curve.is_valid_curve());
   cout << "Checking valid curve...OK" << endl;

#if DEBUG_LEVEL > 1
   /* Valid curve */
   cout << curve << endl;

   /* Test g2hcurve::operator<< */
   cout << curve << endl;
#endif

   /* Another valid curve with h(x) = 0. Assume char is not 2 */
   cout << "- Valid curve 2 - " << endl;

   do {
     random(f, 6); // deg(f) < 6
     SetCoeff(f, 5, 1); // f5 = 1;
   } while (!DetIrredTest(f));

   curve.set_f(f);

   clear(h); // h = 0
   curve.set_h(h);
   curve.update();

   assert(curve.is_valid_curve());
   cout << "Checking valid curve (h = 0)...OK" << endl;

#if DEBUG_LEVEL > 1
   cout << curve << endl;
#endif

   /* Test invalid curve: not genus 2 */
   cout << "- Invalid curve 1: not genus 2 -" << endl;

   NTL_NNS random(f, 5); // degree < 5
   MakeMonic(f);
   curve.set_f(f); 
   curve.update();

   assert(!curve.is_valid_curve());
   cout << "Checking invalid curve: not genus 2...OK" << endl;

#if DEBUG_LEVEL > 1
   cout << curve << endl;
#endif

   /* Test invalid curve: singular */
   cout << "- Invalid curve 2: singular -" << endl;

   set(f); 
   SetCoeff(f, 2, 1);
   SetCoeff(f, 1, 2); // f = x^2 + 2x + 1 = (x + 1)^2
   clear(h); // h = 0

   curve.set_f(f);
   curve.set_h(h);
   curve.update();

   assert(!curve.is_valid_curve());
   cout << "Checking invalid curve: singular...OK" << endl;

#if DEBUG_LEVEL > 1
   cout << curve << endl;
#endif

   /* Test invalid curve: f(x) not monic */
   cout << "- Invalid curve 3: f(x) not monic -" << endl;

   SetCoeff(f, 5, 2);

   curve.set_f(f);
   curve.update();

   assert(!curve.is_valid_curve());
   cout << "Checking invalid curve: non-monic f(x)...OK" << endl;

#if DEBUG_LEVEL > 1
   cout << curve << endl;
#endif

   /*****************************************\
      Test divisor basics 
   \*****************************************/

   cout << "\t*** Test divisor routines ***" << endl;

   curve.random(); // Set curve valid

   /* Valid divisor generated by divisor::random() */
   cout << "\t*** Test random divisor ***" << endl;

   div.set_curve(curve); // Set to valid curve

   div.update();

   div.random();

   assert(div.is_valid_divisor());
   cout << "Checking random divisor...OK" << endl;

#if DEBUG_LEVEL > 1
   cout << div << endl;
#endif

   cout << "\t*** Test invalid divisor ***" << endl;

   cout << "- Invalid divisor 1: invalid curve -" << endl;
 
   /* Invalid divisor: invalid curve is a checked runtime error */
   cout << 
"Invalid curve is a checked runtime error for all divisor arithmetic ops"
        << endl << endl;

   /* Invalid divisor: invalid upoly */

   cout << "- Invalid divisor 2: invalid upoly -" << endl;

   SetCoeff(u, genus + 1, 1);  // deg(u) = 3 
   div.set_upoly(u);
   div.update();

   assert(!div.is_valid_divisor());
   cout << "Checking invalid divisor: invalid u(x)...OK" << endl;

#if DEBUG_LEVEL > 1
   cout << div << endl;
#endif


   /* Invliad divisor: invalid vpoly */
   cout << "- Invalid divisor 3: invalid vpoly -" << endl;


   // Test divisor::set_unit, divisor::is_unit()
   cout << "    - Unit divisor -" << endl;

   div.set_unit();

   assert(div.is_unit());
   cout << "Checking unit divisor...OK" << endl;

#if DEBUG_LEVEL > 1
   cout << div << endl;
#endif

   /* Invalid vpoly */
   div.random();  // Valid divisor

   cout << "    - vpoly is set to invalid -" << endl;

   random(v, genus + 1);
   SetCoeff(v, 2, 1); // deg(v) = 1
   div.set_vpoly(v);
   div.update();

   assert(!div.is_valid_divisor());
   cout << "Checking invalid divisor: invalid v(x)...OK" << endl;

#if DEBUG_LEVEL > 1 
   cout << div << endl;
#endif

   /*****************************************\
      Test divisor arithmetic 
   \*****************************************/

   /* Test divisor arithmeitc:
      divisor addition, doubling and scalar multiplication are tested.
      Results return from add() and add_cantor() are compared to test
      correctness. Some results can also be compared to the results
      generated by the CAS MAGMA */

   cout << "\t*** Test divisor arithmetic operations ***" << endl;

   /* Test Divisor negation */
   cout << "\t*** Test negation ***" << endl;
   div1.random();
   dnegate(div2, div1);

   assert(div2.is_valid_divisor());
   cout << "Checking divisor negation...OK" << endl;

#if DEBUG_LEVEL > 1
   cout << "div1: " << endl;
   cout << div1 << endl;

   cout << "div2 = -div1:" << endl;
   cout << div2 << endl;
#endif

   div = div1 + div2;

   assert(div.is_unit());
   cout << "This test should return a unit divisor...OK" << endl;

#if DEBUG_LEVEL > 1
   cout << "div1 + div2: " << endl; 
   cout << div << endl;
#endif

   /* Test divisor addition */
   cout << "\t*** Test addition ***" << endl;

   /* deg 2 + deg 2 */
   cout << "- Addition: deg 2 + deg 2 -" << endl;

   div1.random();

   do {
     div2.random();
   } while (div1 == div2); // Choose diffrent div2

#if DEBUG_LEVEL > 1
   cout << "Random div1: " << endl;
   cout << div1 << endl;
   cout << "Random div2: " << endl;
   cout << div2 << endl;
#endif

   if (add_cantor(divc, div1, div2)) 
     cout << "divc = div1 + div2: add_cantor()" << endl;

#if (DEBUG_LEVEL > 1)
   cout << "divc : " << endl;
   cout << divc << endl;
#endif

   if (add(div, div1, div2))
     cout << "div = div1 + div2: add()" << endl;

   compare(div, divc, "Addtion(2+2)");

   /* deg 2 + deg 1 */
   cout << "- Addition: deg 2 + deg 1 -" << endl;

   div1.random(); // degree 2
   div2.random(DEGREE_1);// degree 1

#if DEBUG_LEVEL > 1
   cout << "Random div1: " << endl;
   cout << div1 << endl;
   cout << "Random div2: " << endl;
   cout << div2 << endl;
#endif

   if (add_cantor(divc, div1, div2)) 
     cout << "divc = div1 + div2: add_cantor()" << endl;

   if (add(div, div1, div2))
     cout << "div = div1 + div2: add()" << endl;

   cout << endl;

   compare(div, divc, "Addition(2+1)");

   /* deg 1 + deg 1 */
   cout << "- Addition: deg 1 + deg 1 -" << endl;

   div1.random(DEGREE_1);
   do {
     div2.random(DEGREE_1);
   } while (div1 == div2);

#if DEBUG_LEVEL > 1
   cout << "Random div1: " << endl;
   cout << div1 << endl;
   cout << "Random div2: " << endl;
   cout << div2 << endl;
#endif

   if (add_cantor(divc, div1, div2)) 
     cout << "divc = div1 + div2: add_cantor()" << endl;

   if (add(div, div1, div2))
     cout << "div = div1 + div2: add()" << endl;
   compare(div, divc, "Addition(1+1)");

   /* deg 2 + unit */
   cout << "- Addition: deg 2 + unit divisor -" << endl;

   div1.random();
   div2.set_unit();

#if DEBUG_LEVEL > 1
   cout << "Random div1: " << endl;
   cout << div1 << endl;
   cout << "Unit div2: " << endl;
   cout << div2 << endl;
#endif

   if (add_cantor(divc, div1, div2))
     cout << "divc = div1 + div2: add_cantor()" << endl;

   if (add(div, div1, div2))
     cout << "div = div1 + div2: add()" << endl;

   compare(div, divc, "Addtion(2+0)");

   assert(div==div1);
   cout << "Checking adding unit divisor...OK" << endl;

   /* unit + unit */
   cout << "- Addition: unit divisor + unit divisor -" << endl;

   div1.set_unit();
   div2.set_unit();

#if DEBUG_LEVEL > 1
   cout << "Unit div1 & div2: " << endl;
   cout << div1 << endl;
#endif

   if (add_cantor(divc, div1, div2))
     cout << "divc = div1 + div2: add_cantor()" << endl;

   if (add(div, div1, div2))
     cout << "div = div1 + div2: add()" << endl;

   compare(div, divc, "Addition(0+0)");

   assert(div==div1);
   cout << "Result should be unit...OK" << endl;

   /* Test commutativity */
   div.random();
   div1.random();
   div2.random();
  
   cout << "\t*** Test commutativity and associativity ***" << endl;
   assert( (div + div1) == (div1 + div));

   cout << "...Commutativity holds" << endl;

   cout << "\t*** Test associativity ***" << endl;
   assert( ((div + div1) + div2) == (div + (div1 + div2)) );

   cout << "...Associativity holds" << endl;

   /* Test divisor doubling */
   cout << "\t*** Test doubling ***" << endl;

   /* [2]* deg_2 */
   cout << "- Doubling: deg 2 -" << endl;

   div1.random();

#if DEBUG_LEVEL > 1
   cout << "Random div1: " << endl;
   cout << div1 << endl;
#endif 

   if (add_cantor(divc, div1, div1))
     cout << "divc = [2]*div1: add_cantor()" << endl;

   if (add(div, div1, div1))
     cout << "div =[2]*div1: add()" << endl;

   compare(div, divc, "Doubling([2]*2)");

   /* [2]* deg_1 */
   cout << "- Doubling: deg 1 -" << endl;

   div1.random(DEGREE_1);

#if DEBUG_LEVEL > 1
   cout << "Random div1: " << endl;
   cout << div1 << endl;
#endif

   if (add_cantor(divc, div1, div1))
     cout << "divc = [2]*div1: add_cantor()" << endl;

   if (add(div, div1, div1))
     cout << "div =[2]*div1: add()" << endl;

   compare(div, divc, "Doubling([2]*1)");

   /* Test divisor subtraction */
   cout << "\t*** Test subtraction ***" << endl;

   div1.random();
   div2.random();

   div = div1 - div2;

#if DEBUG_LEVEL > 1
   cout << "Random div1: " << endl;
   cout << div1 << endl;

   cout << "Random div2: " << endl;
   cout << div2 << endl;

   cout << "div1 - div2: " << endl;
   cout << div << endl;
#endif

   assert(div.is_valid_divisor());
   cout << "Checking subtraction...OK" << endl;

   /* Test scalar multiplication */
   cout << "\t*** Test scalar multiplication ***" << endl;

  do {
   div.random();

   assert(div.is_valid_divisor());
   cout << "Random base divisor generated" << endl;

   cout << "Please choose exponent n (up to " << MAX_STRING_LEN 
<< " decimal digits.  Input '.' to break): " << endl;

   cin.getline(exp, MAX_STRING_LEN);

   if (exp[0] == '.') break;

   n = to_ZZ(exp);

   cout << "Exponent n = " << n << endl;

#if DEBUG_LEVEL > 2
   cout << "div: " << endl;
   cout << div << endl;
#endif

   /* Operator* */

   scalar_mul(div1, div, n, NULL);

   assert(div1.is_valid_divisor());
   cout << "Checking scalar multiplication: square and multiply...OK" << endl;

#if DEBUG_LEVEL > 1
   cout << "[" << n << "]*div: SAM " << endl;
   cout << div1 << endl;
#endif

   scalar_mul(div2, div, n, NAF);
   assert(div2.is_valid_divisor());
   cout << "Checking scalar multiplication: non-adjacent form...OK" << endl;

#if DEBUG_LEVEL > 1
   cout << "[" << n << "]*div: NAF " << endl;
   cout << div2 << endl;
#endif

   scalar_mul(divc, div, n,  ML);
   assert(divc.is_valid_divisor());
   cout << "Checking scalar multiplication: Montgomery's ladder...OK" << endl;

#if DEBUG_LEVEL > 1
   cout << "[" << n << "]*div: ML " << endl;
   cout << divc << endl;
#endif

   assert(div1 == div2 && div2 == divc);
   cout << "Outcomes of three method should agree...OK" << endl;

   /* Test operator* */
   cout << "- Test operator* -" << endl;
   assert( (divc == n*div) && (divc == div*n));
   cout << "Checking operator*...OK" << endl;

  } while (1);

   cout << "**************************************" << endl;
   cout << "  Test completed. Everything seems OK" << endl;
   cout << "**************************************" << endl;

   return 0;
}


static void compare(const divisor& div, const divisor& divc, string ops)
{
   if (divc == div ) {
     cout << ops << " results agree: div equals divc" << endl;
#if DEBUG_LEVEL > 1
     cout << div << endl << endl;
#endif
   } else {
     cout << ops << " arithemetic wrong" << endl;
     assert(0);
   }

}
